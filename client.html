<html>
    <head>
        <script src="/socket.io/socket.io.js"></script>
        <script src="/jq"></script>
    </head>
    <body style="position:relative;">
        <canvas id="myCanvas" style="border:0px;"  oncontextmenu="return RClick()">
            Your browser does not support the HTML5 canvas tag.
        </canvas>
        <script>
            var sprite_scale=1.5, FPS=30,vframe=1;
            var TILES={},
            SPRITES={},//map[id]{S} where S.img, S.size.x, S.size.y
            BOARD={},//.tiles is array of all tiles on the board .x is the width in tiles
            PLAYERS=[],
            OBJECTS={},
            PRIVATE={}
            
            $("body").css("overflow", "hidden");
            var canvas = $("#myCanvas")[0];
            var Font="30px Verdana";
            var socket = io();
            var MY_PLAYER_ID=~~(Math.random()*(1<<16))
            var CLIENT={xoff:0,yoff:0,canvas}
            
            var KEYBOARD = {}
            $(window).keydown(function(e){
                KEYBOARD[e.keyCode]=1
                delete KEYBOARD.goto
            });
            $(window).keyup(function(e){delete KEYBOARD[e.keyCode]});
            $(canvas).click(function(e){
                KEYBOARD.goto={x:CLIENT.xoff+e.clientX,y:CLIENT.yoff+e.clientY}
            })
            
            function RClick(){
                console.log("RC blocked");
                KEYBOARD.goto={x:50,y:50}
                return false;
            }
            function canvasResize(){
                var can = $("#myCanvas")[0]
                can.width = window.innerWidth;
                can.height = window.innerHeight;
            }
            canvasResize()
            $(window).bind("resize", canvasResize);

            canvas.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            document.body.style.backgroundColor = '#111111';
            var ctx = canvas.getContext("2d");
            ctx.fillStyle="#FFFFFF";
            
            socket.on('update', function(msg){
                 PLAYERS=msg.players
            });
            
            socket.on('file4u', function(msg){
                var url=msg.url.replace('???',MY_PLAYER_ID)
                delete KEYBOARD[32]
                switch(msg.type){
                    case 'image/png':                    
                        $.get( url, function( data ) {
                            var imageObj = new Image()
                            imageObj.src = data
                            pid=bigrid()
                            PRIVATE[pid]={x:msg.x,y:msg.y,type:"image",img:imageObj}
                            setTimeout(()=>{
                                delete PRIVATE[pid]
                            },10000)
                        });
                        break;
                    default:
                        $("<a>").attr("href", url).attr("target", "_blank")[0].click();
                }
            });
            socket.on('map', function(msg){
                console.dir({gotmap:msg})
                if(msg.hard||msg.players) PLAYERS=msg.players
                if(msg.hard||msg.map)     BOARD=msg.map
                if(msg.hard||msg.objects) OBJECTS=msg.objects
                //add the new tiles
                for(var t in msg.tiles)if(msg.tiles.hasOwnProperty(t))
                    TILES[t]=msg.tiles[t]
                //add the new sprites
                for(var s in msg.sprites)if(msg.sprites.hasOwnProperty(s)){
                    SPRITES[s]=msg.sprites[s]
                    LoadSpriteSheet(s)
                }
                
            });
            
            function renderBoard(){
                if(!BOARD.tiles){console.log(`Board could not be loaded - should try again in 2s!`); return}
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                var me=PLAYERS[MY_PLAYER_ID]
                
                var drawBoard=(function(){//just for some indented labels, the things we do..
                    for (var t=0;t<BOARD.tiles.length;t++)
                        drawTile(BOARD.tiles[t],t%BOARD.x,~~(t/BOARD.x))//WARN: ~~ limits to 2<<30                    
                })();
            
                //Draw Objects
                for (var o in OBJECTS)if(OBJECTS.hasOwnProperty(o)){
                    var O=OBJECTS[o]
                    draw(O.sprite,O.x*BOARD.xpx,O.y*BOARD.ypx)   
                }
                //Draw Private messages
                for (var o in PRIVATE)if(PRIVATE.hasOwnProperty(o)){
                    var O=PRIVATE[o]
                    switch(O.type){
                        case "image":
                            ctx.drawImage(O.img, O.x, O.y, 600, 600)
                            break;
                        default:
                            draw(O.sprite,O.x*BOARD.xpx,O.y*BOARD.ypx)   
                    }
                }
                //Draw Players
                for (var p in PLAYERS)if(PLAYERS.hasOwnProperty(p)){
                    var P=PLAYERS[p]
                    var alpha = p==MY_PLAYER_ID? //set the alpha of the player we are drawing
                        ( KEYBOARD[16]              ?0.6:1):    //if the player is me, it depends on SHIFT key
                        (!KEYBOARD[16]&&near(P,me,1)?0.5:1);    //if not me, it depends on proximity to me if im not SHIFTing
                    draw(P.sprite,P.x*BOARD.xpx,P.y*BOARD.ypx,P.state,alpha)
                    text((new Array(P.name.length+1)).join("█"),P.x*BOARD.xpx,P.y*BOARD.ypx,'black')   
                    text(P.name,P.x*BOARD.xpx,P.y*BOARD.ypx)   
                    if(p==MY_PLAYER_ID) text("┼",P.x*BOARD.xpx-3,P.y*BOARD.ypx-5,'lightgreen')   
                }  
                
                //scrolling
                meX=me.x*BOARD.xpx*sprite_scale
                meY=me.y*BOARD.ypx*sprite_scale
                
                //≥0 if we are OOB
                OOBLeft =(CLIENT.xoff+100) - meX
                OOBRight=meX - (window.innerWidth+CLIENT.xoff-100)
                OOBUp   =(CLIENT.yoff+100) - meY
                OOBDown =meY - (window.innerHeight+CLIENT.yoff-100)
                
                if(OOBLeft>0)CLIENT.xoff-=OOBLeft
                if(OOBRight>0)CLIENT.xoff+=OOBRight
                if(OOBUp>0)CLIENT.yoff-=OOBUp
                if(OOBDown>0)CLIENT.yoff+=OOBDown
            }
            
            
            //No ajax needed!
            function LoadSpriteSheet(name){
                if(!SPRITES[name])SPRITES[name]={}
                if(SPRITES[name].img)return;
                SPRITES[name].img=new Image()
                SPRITES[name].img.src="spritesheet/"+name
            }
            
            
            
            
            function drawTile(tile,x,y){
                //check we have that TILE
                var T=TILES[tile]
                if(!T){console.log(`Unknown tile ${tile}`); return}
                draw(T.sprite,x*BOARD.xpx,y*BOARD.ypx)
            }
            function draw(sprite,xpx,ypx,state,alpha){//state defaults 0
                //use >, not ≥, to avoid index OOB
                if(sprite.indexOf('.')>0){state=sprite.split('.');sprite=state[0];state=state[1];}
                S= SPRITES[sprite]
                if(!S){console.log(`Unknown sprite ${sprite}`);return}
                
                STATE=S.states[state||0]
                if(!STATE){console.log(`Unknown state ${state} of sprite ${sprite}`);return}
                
                var W=(STATE.size||{}).x || (S.size||{}).x || 16
                var H=(STATE.size||{}).y || (S.size||{}).y || 16
                var xs=(STATE.scale||{}).x || (S.scale||{}).x || 1
                var ys=(STATE.scale||{}).y || (S.scale||{}).y || 1
                var F=STATE.frames[vframe%STATE.frames.length]
                
                var drawImage=()=>{ctx.drawImage(S.img, F.x*W, F.y*H, W, H, sprite_scale*xpx-CLIENT.xoff, sprite_scale*ypx-CLIENT.yoff, sprite_scale*W*xs, sprite_scale*H*ys);}
                alpha=alpha||1
                if(alpha<1){
                    ctx.save()
                    ctx.globalAlpha = alpha
                    drawImage()
                    ctx.restore()
                } else {
                    drawImage()                    
                }
            }
            function text(txt,xpx,ypx,color){
                ctx.fillStyle = color||'white'
                ctx.fillText(txt, sprite_scale*xpx-CLIENT.xoff, sprite_scale*ypx-CLIENT.yoff); 
            }
            
            function init(){            
                var urlid=location.href.split('=')[1].split('-')
                socket.emit('login', {pid:MY_PLAYER_ID,sid:urlid[0],cid:urlid[1]});
                socket.emit('getmap',{id:1})
                
                setInterval( mainloop, 1000/FPS );
                setInterval( function(){vframe++}, 250 );
            }
            init()
            var LastCState="",CState={};
            function mainloop(){
                if(!PLAYERS[MY_PLAYER_ID])return
                var myx=PLAYERS[MY_PLAYER_ID].x*BOARD.xpx*sprite_scale
                var myy=PLAYERS[MY_PLAYER_ID].y*BOARD.ypx*sprite_scale
                var erx=BOARD.xpx*sprite_scale*0.1
                var ery=BOARD.ypx*sprite_scale*0.1
                var goto=KEYBOARD.goto||{}
                var CState=clean({
                    w:KEYBOARD[87]||goto.y<myy-ery,
                    a:KEYBOARD[65]||goto.x<myx-erx,
                    s:KEYBOARD[83]||goto.y>myy+ery,
                    d:KEYBOARD[68]||goto.x>myx+erx,
                    space:KEYBOARD[32],
                    shift:KEYBOARD[16]
                })
                anykey=CState.w||CState.a||CState.s||CState.d||CState.space
                
                //Control modules will load here
                PlayerState=function(s){
                    PLAYERS[MY_PLAYER_ID].state=s
                }
                if(PLAYERS[MY_PLAYER_ID]){
                    if(CState.w)    PlayerState("wwalk")
                    if(CState.a)    PlayerState("awalk")
                    if(CState.s)    PlayerState("swalk")
                    if(CState.d)    PlayerState("dwalk")     
                    if(CState.space)PlayerState("spin")                
                    if(!anykey){ PlayerState(0); delete KEYBOARD.goto    }
                }
                CState.PState=PLAYERS[MY_PLAYER_ID].state
                var SCState=JSON.stringify(CState)
                if(SCState!=LastCState)socket.emit('ControlState', CState);
                
                renderBoard()
                //stop on lose focus
                LastCState=SCState
            }
            function clean(inp){
                var o={}
                for(var i in inp)
                    if(inp.hasOwnProperty(i))
                        if(inp[i]!=undefined)
                           o[i]=inp[i] 
                return o         
            }
            
            var holder = $('body')[0]

            if (typeof window.FileReader === 'undefined') console.log('File api unavailable')
            
            holder.ondragover = function () { return false; };
            holder.ondragend  = function () { return false; };
            holder.ondrop = function (e) {
                e.preventDefault();
                var file = e.dataTransfer.files[0],
                    reader = new FileReader();
                reader.onload = function (event) {
                    if(file.size>10*1024*1024){//10MB
                        console.log("File too big:"+file.size)
                        return 
                    }
                    socket.emit('fileup',{name:file.name,type:file.type,data:event.target.result})
                };
                reader.readAsDataURL(file);
                return false;
            };
            
            //Expects a and b to have x and y properties. determines if the xy of a is ±near of b.
            //If a has .w and .h, those will be used to determine the hitbox, near may also be given.
            function near(a,b,dist){
                if(isNaN(a.x)||isNaN(a.y)||isNaN(b.x)||isNaN(b.y)){
                    console.log("Bad comparison");
                    return;
                }
                dist=isNaN(dist)?1:dist
                if(
                    a.x-(dist||0)<=b.x &&
                    a.x+(dist||0)+(a.w||0)>=b.x && 
                    a.y-(dist||0)<=b.y &&
                    a.y+(dist||0)+(a.h||0)>=b.y
                ) return true   
            }
            //random id
            function grid(){      return ~~(Math.random()*(1<<24))         }
            function bigrid(){    return grid()*grid()+''+grid()*grid()    }

        </script>
    </body>
</html>